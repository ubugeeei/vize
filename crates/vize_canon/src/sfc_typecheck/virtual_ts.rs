//! Virtual TypeScript generation for Vue SFC type checking.

use vize_carton::{push_all, push_line};

/// Generate virtual TypeScript using croquis scope information.
///
/// This generates TypeScript code that reflects the actual scope chain
/// from croquis analysis. It wraps everything in a generic setup function
/// to support `<script setup generic="T">` and creates nested scopes
/// using real JavaScript scoping (closures, for-of, etc.).
pub fn generate_virtual_ts_with_scopes(
    summary: &vize_croquis::Croquis,
    script_content: Option<&str>,
    script_offset: u32,
    _template_ast: Option<&vize_relief::ast::RootNode<'_>>,
    template_offset: u32,
) -> String {
    let mut ts = String::with_capacity(8192);

    // Extract imports from script content for hoisting
    let (hoisted_imports, script_without_imports, import_end_offset) =
        if let Some(script) = script_content {
            extract_imports_with_offset(script)
        } else {
            (Vec::new(), String::new(), 0)
        };

    // Header
    ts.push_str("// ============================================\n");
    ts.push_str("// Virtual TypeScript for Vue SFC Type Checking\n");
    ts.push_str("// Generated by vize_canon with croquis scopes\n");
    ts.push_str("// ============================================\n\n");

    // Vue Runtime Type Declarations
    ts.push_str("// ========== Vue Runtime Types ==========\n");
    ts.push_str(VUE_RUNTIME_TYPES);
    ts.push_str("\n\n");

    // Hoisted imports from script content
    if !hoisted_imports.is_empty() {
        ts.push_str("// ========== Hoisted Imports ==========\n");
        for import in &hoisted_imports {
            ts.push_str(import);
            ts.push('\n');
        }
        ts.push('\n');
    }

    // ========== Props Interface ==========
    ts.push_str("// ========== Props Interface ==========\n");
    let props = summary.macros.props();
    if !props.is_empty() {
        ts.push_str("interface __VizeProps {\n");
        for prop in props {
            let type_str = prop
                .prop_type
                .as_ref()
                .map(|t| t.as_str())
                .unwrap_or("unknown");
            ts.push_str("  ");
            ts.push_str(&prop.name);
            if !prop.required {
                ts.push('?');
            }
            ts.push_str(": ");
            ts.push_str(type_str);
            ts.push_str(";\n");
        }
        ts.push_str("}\n\n");
    } else {
        ts.push_str("interface __VizeProps {}\n\n");
    }

    // ========== Emits Interface ==========
    ts.push_str("// ========== Emits Interface ==========\n");
    let emits = summary.macros.emits();
    if !emits.is_empty() {
        ts.push_str("interface __VizeEmits {\n");
        for emit in emits {
            let payload_type = emit
                .payload_type
                .as_ref()
                .map(|t| t.as_str())
                .unwrap_or("void");
            ts.push_str("  (e: '");
            ts.push_str(&emit.name);
            ts.push_str("', payload: ");
            ts.push_str(payload_type);
            ts.push_str("): void;\n");
        }
        ts.push_str("}\n\n");
    } else {
        ts.push_str("interface __VizeEmits {}\n\n");
    }

    // ========== Slots Interface ==========
    ts.push_str("// ========== Slots Interface ==========\n");
    ts.push_str("interface __VizeSlots {\n");
    ts.push_str("  [name: string]: ((props: Record<string, unknown>) => any) | undefined;\n");
    ts.push_str("}\n\n");

    // ========== Generic Setup Function ==========
    // This wraps the entire component in a generic function to support
    // <script setup generic="T extends SomeType">
    ts.push_str("// ========== Generic Setup Function ==========\n");
    ts.push_str("// Supports <script setup generic=\"T\">\n");
    ts.push_str("function __setup<\n");
    ts.push_str("  __Props extends __VizeProps = __VizeProps,\n");
    ts.push_str("  __Emits extends __VizeEmits = __VizeEmits,\n");
    ts.push_str("  __Slots extends __VizeSlots = __VizeSlots,\n");
    ts.push_str(">(\n");
    ts.push_str("  __props: __Props,\n");
    ts.push_str("  __ctx: {\n");
    ts.push_str("    emit: __Emits;\n");
    ts.push_str("    slots: __Slots;\n");
    ts.push_str("    attrs: Record<string, unknown>;\n");
    ts.push_str("    expose: (exposed?: Record<string, unknown>) => void;\n");
    ts.push_str("  }\n");
    ts.push_str(") {\n");

    // ========== Models ==========
    let models = summary.macros.models();
    if !models.is_empty() {
        ts.push_str("  // defineModel bindings\n");
        for model in models {
            let name = if model.name.is_empty() {
                "modelValue"
            } else {
                model.name.as_str()
            };
            let type_str = model
                .model_type
                .as_ref()
                .map(|t| t.as_str())
                .unwrap_or("unknown");
            ts.push_str("  const ");
            ts.push_str(name);
            ts.push_str(": import('vue').ModelRef<");
            ts.push_str(type_str);
            ts.push_str("> = undefined!;\n");
        }
        ts.push('\n');
    }

    // ========== Script Setup Content (imports hoisted) ==========
    if !script_without_imports.is_empty() {
        ts.push_str("  // ========== Script Setup Content ==========\n");

        // Track positions for source mapping
        // NOTE: We output script content WITHOUT indentation so that character
        // positions map 1:1 with the source. This is required for accurate
        // diagnostic position mapping.
        let gen_start = ts.len();
        let src_start = script_offset as usize + import_end_offset;

        // Output script content directly (no indentation for accurate mapping)
        ts.push_str(&script_without_imports);
        if !script_without_imports.ends_with('\n') {
            ts.push('\n');
        }

        let gen_end = ts.len();
        let src_end = src_start + script_without_imports.len();

        // Emit source map marker for script content
        // Format: // @vize-map: genStart:genEnd -> srcStart:srcEnd
        push_line!(ts, "  // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);
        ts.push('\n');
    }

    // ========== Template Function ==========
    // Template is a function inside setup to access all setup bindings
    // and Vue globals. This enables proper scope chain for type checking.
    ts.push_str("  // ========== Template Function ==========\n");
    ts.push_str("  function __template() {\n");
    ts.push_str("    // Vue instance context (template-scoped)\n");
    ts.push_str("    // Properties\n");
    ts.push_str("    const $data: Record<string, unknown> = {};\n");
    ts.push_str("    const $props = __props;\n");
    ts.push_str("    const $el: HTMLElement | undefined = undefined;\n");
    ts.push_str("    const $options: Record<string, unknown> = {};\n");
    ts.push_str("    const $parent: any = undefined;\n");
    ts.push_str("    const $root: any = undefined;\n");
    ts.push_str("    const $slots = __ctx.slots;\n");
    ts.push_str("    const $refs: Record<string, any> = {};\n");
    ts.push_str("    const $attrs = __ctx.attrs;\n");
    ts.push_str("    // Methods\n");
    ts.push_str("    const $emit = __ctx.emit;\n");
    ts.push_str("    const $watch: (source: string | (() => any), callback: (newVal: any, oldVal: any) => void, options?: { immediate?: boolean; deep?: boolean }) => () => void = undefined!;\n");
    ts.push_str("    const $forceUpdate: () => void = undefined!;\n");
    ts.push_str("    const $nextTick: (callback?: () => void) => Promise<void> = undefined!;\n\n");

    // Mark script setup bindings as used (for unused variable detection)
    // This ensures bindings used in template don't trigger "unused" warnings
    // Skip Props/PropsAliased as they are properties of the props object, not standalone variables
    ts.push_str("    // Script setup bindings (mark as used for unused detection)\n");
    for (name, binding_type) in summary.bindings.bindings.iter() {
        // Props bindings are accessed via props.name, not as standalone variables
        if !matches!(
            binding_type,
            vize_croquis::BindingType::Props | vize_croquis::BindingType::PropsAliased
        ) {
            ts.push_str("    void ");
            ts.push_str(name);
            ts.push_str(";\n");
        }
    }
    ts.push('\n');

    // Generate nested template scopes inside __template function
    generate_template_scopes(&mut ts, summary, template_offset, 2);

    // Generate template expressions for type checking
    if !summary.template_expressions.is_empty() {
        ts.push_str("    // ========== Template Expressions ==========\n");
        for expr in &summary.template_expressions {
            let src_start = template_offset + expr.start;
            let src_end = template_offset + expr.end;

            // Output expression comment
            push_line!(ts, "    // ", expr.kind.as_str(), " @", @src_start, #':', @src_end);

            // Output expression with source map
            let gen_start = ts.len();
            push_line!(ts, "    void (", &expr.content, ");");
            let gen_end = ts.len();

            // Emit source map marker
            push_line!(ts, "    // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);
        }
        ts.push('\n');
    }

    ts.push_str("  }\n\n");

    // ========== Return Statement ==========
    ts.push_str("  // Component render return\n");
    ts.push_str("  return __template;\n");

    ts.push_str("}\n\n");

    // ========== Undefined Reference Errors ==========
    // Filter out refs that are defined in a v-for scope (false positives from :key on v-for elements)
    let filtered_refs: Vec<_> = summary
        .undefined_refs
        .iter()
        .filter(|undef| {
            let ref_offset = undef.offset;
            // Check if this ref is within a v-for scope and matches the v-for variable
            !summary.scopes.iter().any(|scope| {
                if let vize_croquis::ScopeData::VFor(data) = scope.data() {
                    // Check if the ref is within the v-for scope span
                    let in_scope = ref_offset >= scope.span.start && ref_offset <= scope.span.end;
                    // Check if the ref name matches any v-for variable
                    let matches_var = data.value_alias == undef.name
                        || data.key_alias.as_ref() == Some(&undef.name)
                        || data.index_alias.as_ref() == Some(&undef.name);
                    in_scope && matches_var
                } else {
                    false
                }
            })
        })
        .collect();

    if !filtered_refs.is_empty() {
        ts.push_str("// ========== Undefined Reference Errors ==========\n");
        ts.push_str("function __undefinedReferenceErrors() {\n");

        for undef in &filtered_refs {
            let src_start = template_offset + undef.offset;
            let src_end = src_start + undef.name.len() as u32;

            push_line!(
                ts,
                "  // @ts-expect-error TS2304: '",
                &undef.name,
                "' is not defined"
            );
            push_line!(ts, "  // Context: ", &undef.context, " @[", @src_start, #':', @src_end, "]");
            push_line!(ts, "  void ", &undef.name, ";");
            ts.push('\n');
        }

        ts.push_str("}\n");
    }

    ts
}

/// Check if a scope is inside a Vue directive scope (v-for, v-slot, event handler).
/// Returns true if the scope's span is contained within any Vue directive scope.
fn is_inside_vue_directive(scope: &vize_croquis::Scope, summary: &vize_croquis::Croquis) -> bool {
    use vize_croquis::ScopeKind;

    let vue_directive_kinds = [
        ScopeKind::VFor,
        ScopeKind::VSlot,
        ScopeKind::EventHandler,
        ScopeKind::ClientOnly,
    ];

    // Check if this scope's span is contained within any Vue directive scope
    for other in summary.scopes.iter() {
        if vue_directive_kinds.contains(&other.kind) {
            // Check span containment (other contains scope)
            if other.span.start <= scope.span.start && scope.span.end <= other.span.end {
                return true;
            }
        }
    }
    false
}

/// Generate nested template scopes with proper JavaScript scoping.
/// Uses croquis scope chain to define identifiers in their correct scopes.
fn generate_template_scopes(
    ts: &mut String,
    summary: &vize_croquis::Croquis,
    template_offset: u32,
    base_indent: usize,
) {
    use vize_croquis::{ScopeData, ScopeKind};

    let indent = "  ".repeat(base_indent);

    // Generate template-specific scopes (v-for, v-slot, event handlers, etc.)
    for scope in summary.scopes.iter() {
        // Skip closures that are not inside a Vue directive scope
        // (e.g., top-level closures in interpolations don't need separate output)
        if scope.kind == ScopeKind::Closure && !is_inside_vue_directive(scope, summary) {
            continue;
        }

        match (scope.kind, scope.data()) {
            // v-for: Real for-of loop with type inference
            (ScopeKind::VFor, ScopeData::VFor(data)) => {
                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;

                push_line!(ts, &indent, "// v-for: ", &data.value_alias, " in ", &data.source, " @", @src_start, #':', @src_end);

                // Use for-of with proper type inference - track source expression position
                let gen_start = ts.len();
                push_line!(
                    ts,
                    &indent,
                    "for (const ",
                    &data.value_alias,
                    " of ",
                    &data.source,
                    ") {"
                );
                let gen_end = ts.len();

                // Emit source map for the for-of statement (covers the source expression)
                push_line!(ts, &indent, "  // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);

                // Index and key variables inside the loop
                if let Some(ref index) = data.index_alias {
                    push_line!(
                        ts,
                        &indent,
                        "  const ",
                        index.as_str(),
                        ": number = 0; // loop index"
                    );
                }
                if let Some(ref key) = data.key_alias {
                    push_line!(
                        ts,
                        &indent,
                        "  const ",
                        key.as_str(),
                        ": string | number = undefined!; // loop key"
                    );
                }

                // Output all bindings defined in this scope
                for (name, binding) in scope.bindings() {
                    if name != data.value_alias.as_str()
                        && data.index_alias.as_ref().map(|i| i.as_str()) != Some(name)
                        && data.key_alias.as_ref().map(|k| k.as_str()) != Some(name)
                    {
                        push_line!(
                            ts,
                            &indent,
                            "  void ",
                            name,
                            "; // ",
                            binding.binding_type.to_vir()
                        );
                    }
                }

                // Output :key expression for type checking
                // Key must be string | number for Vue's reconciliation
                if let Some(ref key_expr) = data.key_expression {
                    let key_gen_start = ts.len();
                    push_line!(
                        ts,
                        &indent,
                        "  const __key: string | number = ",
                        key_expr.as_str(),
                        "; // :key type constraint"
                    );
                    let key_gen_end = ts.len();

                    // Source map for key expression
                    push_line!(ts, &indent, "  // @vize-map: ", @key_gen_start, #':', @key_gen_end, " -> ", @src_start, #':', @src_end);
                }

                // Use the iterator value
                push_line!(ts, &indent, "  void ", &data.value_alias, ";");

                push_all!(ts, &indent, "}\n\n");
            }

            // v-slot: IIFE receiving slot props
            (ScopeKind::VSlot, ScopeData::VSlot(data)) => {
                let slot_name = if data.name.is_empty() {
                    "default"
                } else {
                    data.name.as_str()
                };

                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;
                push_line!(ts, &indent, "// v-slot:", slot_name, " @", @src_start, #':', @src_end);

                // IIFE that receives slot props
                push_line!(
                    ts,
                    &indent,
                    "((__slotProps: Parameters<NonNullable<__Slots['",
                    slot_name,
                    "']>>[0]) => {"
                );

                if !data.prop_names.is_empty() {
                    push_all!(ts, &indent, "  const { ");
                    for (i, prop) in data.prop_names.iter().enumerate() {
                        if i > 0 {
                            ts.push_str(", ");
                        }
                        ts.push_str(prop.as_str());
                    }
                    ts.push_str(" } = __slotProps;\n");

                    for prop in &data.prop_names {
                        push_line!(ts, &indent, "  void ", prop.as_str(), ";");
                    }
                }

                // Output additional bindings from croquis scope
                for (name, binding) in scope.bindings() {
                    if !data.prop_names.iter().any(|p| p.as_str() == name) {
                        push_line!(
                            ts,
                            &indent,
                            "  void ",
                            name,
                            "; // ",
                            binding.binding_type.to_vir()
                        );
                    }
                }

                push_all!(ts, &indent, "})({} as any);\n\n");
            }

            // Event handler: Arrow function with typed $event
            (ScopeKind::EventHandler, ScopeData::EventHandler(data)) => {
                let event_type = get_event_type(&data.event_name);

                // Calculate source position for this handler
                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;

                push_line!(ts, &indent, "// @", &data.event_name, " @", @src_start, #':', @src_end);

                if data.has_implicit_event {
                    push_line!(ts, &indent, "(($event: ", event_type, ") => {");

                    // Output the handler expression with $event and source map
                    if let Some(ref expr) = data.handler_expression {
                        let expr_str = expr.as_str();
                        // Check if it's a simple identifier (method reference)
                        let is_simple_identifier = expr_str
                            .chars()
                            .all(|c| c.is_alphanumeric() || c == '_' || c == '.');

                        let gen_start = ts.len();
                        if is_simple_identifier && !expr_str.contains('(') {
                            // Simple method reference like "handleClick" -> "handleClick($event)"
                            push_line!(ts, &indent, "  ", expr_str, "($event);");
                        } else {
                            // Expression already has parens or is complex, output as-is
                            push_line!(ts, &indent, "  ", expr_str, ";");
                        }
                        let gen_end = ts.len();

                        // Emit source map for the expression
                        push_line!(ts, &indent, "  // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);
                    }
                } else if !data.param_names.is_empty() {
                    push_all!(ts, &indent, "((");
                    for (i, param) in data.param_names.iter().enumerate() {
                        if i > 0 {
                            ts.push_str(", ");
                        }
                        if param.as_str() == "$event"
                            || param.as_str() == "e"
                            || param.as_str() == "event"
                        {
                            push_all!(ts, param.as_str(), ": ", event_type);
                        } else {
                            push_all!(ts, param.as_str(), ": unknown");
                        }
                    }
                    ts.push_str(") => {\n");

                    // Output the handler expression with source map
                    if let Some(ref expr) = data.handler_expression {
                        let gen_start = ts.len();
                        push_line!(ts, &indent, "  ", expr.as_str(), ";");
                        let gen_end = ts.len();

                        push_line!(ts, &indent, "  // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);
                    }
                } else {
                    push_line!(ts, &indent, "(() => {");

                    // Output the handler expression with source map
                    if let Some(ref expr) = data.handler_expression {
                        let gen_start = ts.len();
                        push_line!(ts, &indent, "  ", expr.as_str(), ";");
                        let gen_end = ts.len();

                        push_line!(ts, &indent, "  // @vize-map: ", @gen_start, #':', @gen_end, " -> ", @src_start, #':', @src_end);
                    }
                }

                push_all!(ts, &indent, "})();\n\n");
            }

            // Callback: Arrow function
            (ScopeKind::Callback, ScopeData::Callback(data)) => {
                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;
                push_line!(ts, &indent, "// callback: ", &data.context, " @", @src_start, #':', @src_end);

                push_all!(ts, &indent, "((");
                for (i, param) in data.param_names.iter().enumerate() {
                    if i > 0 {
                        ts.push_str(", ");
                    }
                    push_all!(ts, param.as_str(), ": unknown");
                }
                ts.push_str(") => {\n");

                for param in &data.param_names {
                    push_line!(ts, &indent, "  void ", param.as_str(), ";");
                }

                // Output additional bindings from croquis scope
                for (name, binding) in scope.bindings() {
                    if !data.param_names.iter().any(|p| p.as_str() == name) {
                        push_line!(
                            ts,
                            &indent,
                            "  void ",
                            name,
                            "; // ",
                            binding.binding_type.to_vir()
                        );
                    }
                }

                push_all!(ts, &indent, "})(undefined!);\n\n");
            }

            // Closure: Function expression
            (ScopeKind::Closure, ScopeData::Closure(data)) => {
                let async_kw = if data.is_async { "async " } else { "" };
                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;

                push_line!(ts, &indent, "// closure @", @src_start, #':', @src_end);

                push_all!(ts, &indent, async_kw, "((");
                for (i, param) in data.param_names.iter().enumerate() {
                    if i > 0 {
                        ts.push_str(", ");
                    }
                    push_all!(ts, param.as_str(), ": unknown");
                }
                ts.push_str(") => {\n");

                for param in &data.param_names {
                    push_line!(ts, &indent, "  void ", param.as_str(), ";");
                }

                // Output additional bindings from croquis scope
                for (name, binding) in scope.bindings() {
                    if !data.param_names.iter().any(|p| p.as_str() == name) {
                        push_line!(
                            ts,
                            &indent,
                            "  void ",
                            name,
                            "; // ",
                            binding.binding_type.to_vir()
                        );
                    }
                }

                push_all!(ts, &indent, "})(undefined!);\n\n");
            }

            // Client-only: onMounted etc.
            (ScopeKind::ClientOnly, ScopeData::ClientOnly(data)) => {
                let src_start = template_offset + scope.span.start;
                let src_end = template_offset + scope.span.end;
                push_line!(ts, &indent, "// ", &data.hook_name, " (client-only) @", @src_start, #':', @src_end);

                push_line!(ts, &indent, &data.hook_name, "(() => {");
                push_line!(ts, &indent, "  // Browser APIs available: window, document");

                // Output bindings from croquis scope
                for (name, binding) in scope.bindings() {
                    push_line!(
                        ts,
                        &indent,
                        "  void ",
                        name,
                        "; // ",
                        binding.binding_type.to_vir()
                    );
                }

                push_all!(ts, &indent, "});\n\n");
            }

            _ => {}
        }
    }
}

/// Get TypeScript event type from event name.
fn get_event_type(event_name: &str) -> &'static str {
    match event_name {
        "click" | "dblclick" | "mousedown" | "mouseup" | "mousemove" | "mouseenter"
        | "mouseleave" | "mouseover" | "mouseout" | "contextmenu" => "MouseEvent",
        "keydown" | "keyup" | "keypress" => "KeyboardEvent",
        "input" | "change" | "beforeinput" => "InputEvent",
        "focus" | "blur" | "focusin" | "focusout" => "FocusEvent",
        "submit" | "reset" => "SubmitEvent",
        "scroll" => "Event",
        "wheel" => "WheelEvent",
        "touchstart" | "touchend" | "touchmove" | "touchcancel" => "TouchEvent",
        "drag" | "dragstart" | "dragend" | "dragenter" | "dragleave" | "dragover" | "drop" => {
            "DragEvent"
        }
        "pointerdown" | "pointerup" | "pointermove" | "pointerenter" | "pointerleave"
        | "pointerover" | "pointerout" | "pointercancel" => "PointerEvent",
        "animationstart" | "animationend" | "animationiteration" => "AnimationEvent",
        "transitionstart" | "transitionend" | "transitionrun" | "transitioncancel" => {
            "TransitionEvent"
        }
        "resize" => "UIEvent",
        "copy" | "cut" | "paste" => "ClipboardEvent",
        _ => "Event",
    }
}

/// Extract import statements from script content for hoisting.
/// Returns (hoisted_imports, script_without_imports, byte offset where imports end).
fn extract_imports_with_offset(script: &str) -> (Vec<String>, String, usize) {
    let mut imports = Vec::new();
    let mut remaining_lines = Vec::new();
    let mut import_end_byte = 0;
    let mut current_byte = 0;

    for line in script.lines() {
        let line_len = line.len() + 1; // +1 for newline
        let trimmed = line.trim();
        // Check if line starts with import (including `import type`)
        if trimmed.starts_with("import ") || trimmed.starts_with("import{") {
            imports.push(line.to_string());
            import_end_byte = current_byte + line_len;
        } else {
            remaining_lines.push(line);
        }
        current_byte += line_len;
    }

    (imports, remaining_lines.join("\n"), import_end_byte)
}

/// Vue runtime type declarations for type checking.
pub const VUE_RUNTIME_TYPES: &str = r#"import type {
  Ref,
  ComputedRef,
  UnwrapRef,
  Reactive,
  ShallowRef,
  WritableComputedRef,
} from 'vue';

import {
  ref,
  reactive,
  computed,
  watch,
  watchEffect,
  unref,
  toRef,
  toRefs,
  shallowRef,
  triggerRef,
  customRef,
  readonly,
  onMounted,
  onUnmounted,
  onBeforeMount,
  onBeforeUnmount,
  onUpdated,
  onBeforeUpdate,
  onActivated,
  onDeactivated,
  onErrorCaptured,
  nextTick,
  getCurrentInstance,
  inject,
  provide,
} from 'vue';

type MaybeRef<T> = T | Ref<T>;"#;
