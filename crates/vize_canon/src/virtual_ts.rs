//! Virtual TypeScript generation for Vue SFC type checking.
//!
//! This module generates TypeScript code that represents a Vue SFC's
//! runtime behavior, enabling type checking of template expressions
//! and script setup bindings.
//!
//! Key design: Uses closures from Croquis scope information instead of
//! `declare const` to properly model Vue's template scoping.

use vize_croquis::{Croquis, ScopeData, ScopeKind};

/// Vue runtime type declarations for type checking.
/// Only script setup macros - Vue instance context is in template closure.
pub const VUE_RUNTIME_TYPES: &str = r#"// Vue SFC compiler macros (available globally in <script setup>)
declare function defineProps<T>(): T;
declare function defineEmits<T>(): T;
declare function defineExpose<T>(exposed?: T): void;
declare function defineModel<T>(name?: string, options?: any): any;
declare function withDefaults<T, D>(props: T, defaults: D): T & D;"#;

/// Vue template context - available inside template expressions
const VUE_TEMPLATE_CONTEXT: &str = r#"  // Vue instance context (available in template)
  const $attrs: Record<string, unknown> = {} as any;
  const $slots: Record<string, (...args: any[]) => any> = {} as any;
  const $refs: Record<string, any> = {} as any;
  const $emit: (...args: any[]) => void = (() => {}) as any;
  const $event: Event = {} as Event;"#;

/// Generate virtual TypeScript from Vue SFC analysis.
///
/// The generated TypeScript includes:
/// - Vue runtime type imports
/// - The original script content
/// - Proper closures for v-for, v-slot scopes
/// - Template expressions type-checked in their scope context
pub fn generate_virtual_ts(
    summary: &Croquis,
    script_content: Option<&str>,
    template_ast: Option<&vize_relief::ast::RootNode<'_>>,
    template_offset: u32,
) -> String {
    let mut ts = String::new();

    // Header
    ts.push_str("// ============================================\n");
    ts.push_str("// Virtual TypeScript for Vue SFC Type Checking\n");
    ts.push_str("// Generated by vize\n");
    ts.push_str("// ============================================\n\n");

    // Vue Runtime Type Declarations
    ts.push_str("// ========== Vue Runtime Types ==========\n");
    ts.push_str(VUE_RUNTIME_TYPES);
    ts.push_str("\n\n");

    // Original Script
    if let Some(script) = script_content {
        ts.push_str("// ========== Script Setup ==========\n");
        let script_gen_start = ts.len();
        ts.push_str(script);
        let script_gen_end = ts.len();
        ts.push('\n');
        // Source map marker
        ts.push_str(&format!(
            "// @vize-map: {}:{} -> 0:{}\n\n",
            script_gen_start,
            script_gen_end,
            script.len()
        ));
    }

    // Props type generation
    generate_props_type(&mut ts, summary);

    // Emits type
    let emits_already_defined = summary
        .type_exports
        .iter()
        .any(|te| te.name.as_str() == "Emits");
    if !emits_already_defined {
        ts.push_str("export type Emits = {};\n");
    }
    ts.push_str("export type Slots = {};\n\n");

    // Template Type Verification with proper closures
    if template_ast.is_some() {
        ts.push_str("// ========== Template Type Verification ==========\n");

        // Check for generic type parameter from <script setup generic="T">
        let generic_param = summary
            .scopes
            .iter()
            .find(|s| matches!(s.kind, ScopeKind::ScriptSetup))
            .and_then(|s| {
                if let ScopeData::ScriptSetup(data) = s.data() {
                    data.generic.as_ref().map(|s| s.as_str())
                } else {
                    None
                }
            });

        // Generate function with optional generic
        if let Some(generic) = generic_param {
            ts.push_str(&format!(
                "function __verifyTemplateTypes<{}>() {{\n",
                generic
            ));
        } else {
            ts.push_str("function __verifyTemplateTypes() {\n");
        }

        // Vue template context (available in template expressions)
        ts.push_str(VUE_TEMPLATE_CONTEXT);
        ts.push_str("\n\n");

        // Generate scope closures
        generate_scope_closures(&mut ts, summary, template_offset);

        ts.push_str("}\n\n");
    }

    // Default export
    ts.push_str("// ========== Default Export ==========\n");
    ts.push_str("declare const __vize_component__: {\n");
    ts.push_str("  props: Props;\n");
    ts.push_str("  emits: Emits;\n");
    ts.push_str("  slots: Slots;\n");
    ts.push_str("};\n");
    ts.push_str("export default __vize_component__;\n");

    ts
}

/// Generate Props type definition
fn generate_props_type(ts: &mut String, summary: &Croquis) {
    let props = summary.macros.props();
    let has_props = !props.is_empty();
    let define_props_type_args = summary
        .macros
        .define_props()
        .and_then(|m| m.type_args.as_ref());
    let props_already_defined = summary
        .type_exports
        .iter()
        .any(|te| te.name.as_str() == "Props");

    ts.push_str("// ========== Exported Types ==========\n");

    if props_already_defined {
        // User defined Props, no need to re-export
    } else if let Some(type_args) = define_props_type_args {
        let inner_type = type_args
            .strip_prefix('<')
            .and_then(|s| s.strip_suffix('>'))
            .unwrap_or(type_args.as_str());
        let is_simple_reference = inner_type
            .chars()
            .all(|c: char| c.is_alphanumeric() || c == '_');
        if is_simple_reference
            && summary
                .type_exports
                .iter()
                .any(|te| te.name.as_str() == inner_type)
        {
            // Type arg references existing type
        } else {
            ts.push_str(&format!("export type Props = {};\n", inner_type));
        }
    } else if has_props {
        ts.push_str("export type Props = {\n");
        for prop in props {
            let prop_type = prop.prop_type.as_deref().unwrap_or("unknown");
            let optional = if prop.required { "" } else { "?" };
            ts.push_str(&format!("  {}{}: {};\n", prop.name, optional, prop_type));
        }
        ts.push_str("};\n");
    } else {
        ts.push_str("export type Props = {};\n");
    }

    // Props variable declarations for template access
    if has_props || define_props_type_args.is_some() {
        ts.push_str("\n// Props are available in template as variables\n");
        ts.push_str("const __props: Props = {} as Props;\n");
        for prop in props {
            ts.push_str(&format!(
                "const {} = __props[\"{}\"];\n",
                prop.name, prop.name
            ));
        }
    }
    ts.push('\n');
}

/// Generate scope closures from Croquis scope chain
fn generate_scope_closures(ts: &mut String, summary: &Croquis, template_offset: u32) {
    use std::collections::HashMap;

    // Group expressions by scope_id
    let mut expressions_by_scope: HashMap<u32, Vec<_>> = HashMap::new();
    for expr in &summary.template_expressions {
        expressions_by_scope
            .entry(expr.scope_id.as_u32())
            .or_default()
            .push(expr);
    }

    // Track generated scopes to avoid duplicates
    let mut generated_scopes = std::collections::HashSet::new();

    // Generate closures for each scope that has expressions or creates bindings
    for scope in summary.scopes.iter() {
        let scope_id = scope.id.as_u32();

        // Skip root/global scopes
        if matches!(
            scope.kind,
            ScopeKind::JsGlobalUniversal
                | ScopeKind::JsGlobalBrowser
                | ScopeKind::JsGlobalNode
                | ScopeKind::VueGlobal
        ) {
            continue;
        }

        match scope.data() {
            ScopeData::VFor(data) => {
                if generated_scopes.insert(scope_id) {
                    // Generate v-for closure
                    ts.push_str(&format!(
                        "\n  // v-for scope: {} in {}\n",
                        data.value_alias, data.source
                    ));

                    // Infer element type from source
                    let element_type = format!("typeof {}[number]", data.source);

                    // Build parameter list with proper types
                    // For arrays: (item: T, index: number)
                    // For objects: (value: T, key: string, index: number)
                    ts.push_str(&format!(
                        "  {}.forEach(({}: {}",
                        data.source, data.value_alias, element_type
                    ));

                    if let Some(ref key) = data.key_alias {
                        // key is string for objects, number for arrays
                        ts.push_str(&format!(", {}: number", key));
                    }
                    if let Some(ref index) = data.index_alias {
                        // When index_alias exists, we have (value, key, index) for objects
                        // key is string, index is number
                        if data.key_alias.is_none() {
                            ts.push_str(", _key: number");
                        }
                        ts.push_str(&format!(", {}: number", index));
                    }

                    ts.push_str(") => {\n");

                    // Generate expressions in this scope
                    if let Some(exprs) = expressions_by_scope.get(&scope_id) {
                        for expr in exprs {
                            let src_start = template_offset + expr.start;
                            let src_end = template_offset + expr.end;

                            ts.push_str(&format!(
                                "    const __expr_{} = {}; // {}\n",
                                expr.start,
                                expr.content,
                                expr.kind.as_str()
                            ));
                            ts.push_str(&format!(
                                "    // @vize-map: expr -> {}:{}\n",
                                src_start, src_end
                            ));
                        }
                    }

                    ts.push_str("  });\n");
                }
            }
            ScopeData::VSlot(data) => {
                if generated_scopes.insert(scope_id) {
                    // Generate v-slot closure
                    ts.push_str(&format!("\n  // v-slot scope: #{}\n", data.name));

                    let props_pattern = data.props_pattern.as_deref().unwrap_or("slotProps");
                    ts.push_str(&format!(
                        "  const __slot_{} = ({}: any) => {{\n",
                        data.name, props_pattern
                    ));

                    // Generate expressions in this scope
                    if let Some(exprs) = expressions_by_scope.get(&scope_id) {
                        for expr in exprs {
                            let src_start = template_offset + expr.start;
                            let src_end = template_offset + expr.end;

                            ts.push_str(&format!(
                                "    const __expr_{} = {}; // {}\n",
                                expr.start,
                                expr.content,
                                expr.kind.as_str()
                            ));
                            ts.push_str(&format!(
                                "    // @vize-map: expr -> {}:{}\n",
                                src_start, src_end
                            ));
                        }
                    }

                    ts.push_str("  };\n");
                }
            }
            ScopeData::EventHandler(data) => {
                if generated_scopes.insert(scope_id) {
                    // Generate event handler closure
                    ts.push_str(&format!("\n  // @{} handler\n", data.event_name));

                    if data.has_implicit_event {
                        ts.push_str("  const __handler = ($event: Event) => {\n");
                    } else if !data.param_names.is_empty() {
                        let params: Vec<_> = data.param_names.iter().map(|s| s.as_str()).collect();
                        ts.push_str(&format!(
                            "  const __handler = ({}: any) => {{\n",
                            params.join(", ")
                        ));
                    } else {
                        ts.push_str("  const __handler = () => {\n");
                    }

                    // Generate expressions in this scope
                    if let Some(exprs) = expressions_by_scope.get(&scope_id) {
                        for expr in exprs {
                            ts.push_str(&format!("    {};  // handler expression\n", expr.content));
                        }
                    }

                    ts.push_str("  };\n");
                }
            }
            _ => {
                // For other scopes (Template, ScriptSetup, etc.), just generate expressions
                if let Some(exprs) = expressions_by_scope.get(&scope_id) {
                    for expr in exprs {
                        let src_start = template_offset + expr.start;
                        let src_end = template_offset + expr.end;

                        ts.push_str(&format!(
                            "  const __expr_{} = {}; // {}\n",
                            expr.start,
                            expr.content,
                            expr.kind.as_str()
                        ));
                        ts.push_str(&format!(
                            "  // @vize-map: expr -> {}:{}\n",
                            src_start, src_end
                        ));
                    }
                }
            }
        }
    }

    // Handle undefined references
    if !summary.undefined_refs.is_empty() {
        ts.push_str("\n  // Undefined references from template:\n");
        let mut seen_names: std::collections::HashSet<&str> = std::collections::HashSet::new();
        for undef in &summary.undefined_refs {
            if !seen_names.insert(undef.name.as_str()) {
                continue;
            }

            let src_start = template_offset + undef.offset;
            let src_end = src_start + undef.name.len() as u32;

            let gen_start = ts.len();
            let expr_code = format!("  const __undef_{} = {};\n", undef.name, undef.name);
            let name_offset = expr_code.find(undef.name.as_str()).unwrap_or(0);
            let gen_name_start = gen_start + name_offset;
            let gen_name_end = gen_name_start + undef.name.len();

            ts.push_str(&expr_code);
            ts.push_str(&format!(
                "  // @vize-map: {}:{} -> {}:{}\n",
                gen_name_start, gen_name_end, src_start, src_end
            ));
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vue_runtime_types_contains_declarations() {
        // Script setup macros
        assert!(VUE_RUNTIME_TYPES.contains("declare function defineProps"));
        assert!(VUE_RUNTIME_TYPES.contains("declare function defineEmits"));
        // Template context (moved from VUE_RUNTIME_TYPES to VUE_TEMPLATE_CONTEXT)
        assert!(VUE_TEMPLATE_CONTEXT.contains("$attrs"));
        assert!(VUE_TEMPLATE_CONTEXT.contains("$slots"));
    }
}
